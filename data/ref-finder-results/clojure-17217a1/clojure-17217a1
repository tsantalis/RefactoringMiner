move_field("ZERO","clojure.lang%.BigInt","clojure.lang%.ClojureBigInteger")
add_parameter("clojure.lang%.LockingTransaction#releaseIfEnsured()","Reference:ref")
extract_interface("clojure.asm.commons%.IStackablle","clojure.asm.commons%.InstructionAdapter")
move_method("invoke()","clojure.lang%.Ref","clojure.lang%.Variable")
remove_parameter("clojure.lang%.LockingTransaction#lock()","Ref:ref")
move_method("find()","clojure.lang%.Var","clojure.lang%.Symbol")
replace_method_with_method_object("clojure.lang%.ArraySeq#ArraySeq_long#next()","clojure.lang%.ClojureObject")
add_parameter("clojure.lang%.LockingTransaction#doGet()","Reference:ref")
consolidate_duplicate_cond_fragments("clojure.lang%.Numbers#toBigInt()")
extract_method("clojure.lang%.Compiler#ObjExpr#compile()","clojure.lang%.Compiler#ObjExpr#getStringMap()","SMAPn+((source.lastIndexOf('.')>0)?source.substring(0,source.lastIndexOf('.')):source)+.javan+Clojuren+*SClojuren+*Fn++1+source+n+(String)SOURCE_PATH.deref()+n+*Ln+String.format(%d#1,%d:%dn,lineBefore,lineAfter-lineBefore,lineBefore)+*E","clojure.lang%.Compiler#ObjExpr")
move_method("setMacro()","clojure.lang%.Var","clojure.lang%.Variable")
move_method("call()","clojure.lang%.Var","clojure.lang%.Variable")
move_field("prev","clojure.lang%.Var#Frame","clojure.lang%.Variable#Frame")
rename_method("clojure.lang%.PersistentList#EmptyList#equiv()","clojure.lang%.PersistentList#EmptyList#isEquivalent()","clojure.lang%.PersistentList#EmptyList")
extract_method("clojure.lang%.Compiler#FnMethod#parse()","clojure.lang%.Compiler#FnMethod#getFnMethod()","FnMethodmethod=newFnMethod(objx,(ObjMethod)METHOD.deref())method.line=lineDeref()method.column=columnDeref()method","clojure.lang%.Compiler#FnMethod")
move_field("bipart","clojure.lang%.BigInt","clojure.lang%.ClojureBigInteger")
move_method("isPublic()","clojure.lang%.Var","clojure.lang%.Variable")
extract_superclass("clojure.asm%.AnnotationVisitor","clojure.asm%.ObjectVisitor")
rename_method("clojure.lang%.AFunction#1#meta()","clojure.lang%.AFunction#1#getMeta()","clojure.lang%.AFunction#1")
rename_method("clojure.lang%.AReference#meta()","clojure.lang%.AReference#getMeta()","clojure.lang%.AReference")
extract_interface("clojure.lang.interfaces%.IFn","clojure.lang%.AFn")
remove_parameter("clojure.lang%.Compiler#TheVarExpr#<init>()","Var:var")
move_method("getThreadBinding()","clojure.lang%.Var","clojure.lang%.Variable")
consolidate_cond_expression("clojure.lang%.LispReader#EvalReader#invoke()")
move_method("create()","clojure.lang%.Var","clojure.lang%.Variable")
replace_method_with_method_object("clojure.lang%.Compiler#ObjExpr#compile()","clojure.lang%.Variable")
move_field("bindings","clojure.lang%.Var#Frame","clojure.lang%.Variable#Frame")
move_method("hasheq()","clojure.lang%.BigInt","clojure.lang%.ClojureBigInteger")
inline_method("clojure.lang%.ASeq#subList()","clojure.lang%.ASeq#reify()","Collections.unmodifiableList(newArrayList(this))","clojure.lang%.ASeq")
replace_method_with_method_object("clojure.lang%.LispReader#matchNumber()","clojure.lang%.ClojureBigInteger")
move_field("macroKey","clojure.lang%.Var","clojure.lang%.Variable")
replace_method_with_method_object("clojure.lang%.LispReader#EvalReader#invoke()","clojure.lang%.Variable")
add_parameter("clojure.lang%.LockingTransaction#doCommute()","Reference:ref")
move_method("hashCode()","clojure.lang%.BigInt","clojure.lang%.ClojureBigInteger")
move_method("getThreadBindings()","clojure.lang%.Var","clojure.lang%.Variable")
remove_parameter("clojure.lang%.Compiler#InvokeExpr#sigTag()","Var:v")
move_method("invoke()","clojure.lang%.Var#3","clojure.lang%.Variable#3")
replace_method_with_method_object("clojure.lang%.ArraySeq#ArraySeq_double#next()","clojure.lang%.ClojureObject")
extract_interface("clojure.lang%.IClojureObject","clojure.lang%.PersistentVector")
move_field("thread","clojure.lang%.Var#TBox","clojure.lang%.Variable#TBox")
consolidate_duplicate_cond_fragments("clojure.lang%.RT#print()")
replace_method_with_method_object("clojure.lang%.Compiler#InvokeExpr#<init>()","clojure.lang%.Variable")
rename_method("clojure.lang%.APersistentVector#equiv()","clojure.lang%.APersistentVector#isEquivalent()","clojure.lang%.APersistentVector")
replace_method_with_method_object("clojure.lang%.ArraySeq#ArraySeq_float#next()","clojure.lang%.ClojureObject")
replace_method_with_method_object("clojure.lang%.Compiler#IfExpr#Parser#parse()","clojure.lang%.Variable")
extract_interface("clojure.lang%.IClojureObject","clojure.lang%.PersistentHashSet")
move_method("resetThreadBindingFrame()","clojure.lang%.Var","clojure.lang%.Variable")
extract_interface("clojure.lang%.IClojureObject","clojure.lang%.PersistentTreeSet")
move_method("set()","clojure.lang%.Ref","clojure.lang%.Reference")
move_field("av","clojure.asm%.AnnotationVisitor","clojure.asm%.ObjectVisitor")
replace_method_with_method_object("clojure.lang%.Compiler#StaticMethodExpr#emit()","clojure.lang%.Variable")
move_field("dynamic","clojure.lang%.Var","clojure.lang%.Variable")
move_field("val","clojure.lang%.Ref#TVal","clojure.lang%.Reference#TVal")
move_method("fn()","clojure.lang%.Ref","clojure.lang%.Reference")
move_method("cloneThreadBindingFrame()","clojure.lang%.Var","clojure.lang%.Variable")
move_method("add()","clojure.lang%.BigInt","clojure.lang%.ClojureBigInteger")
move_method("toString()","clojure.lang%.Var","clojure.lang%.Variable")
add_parameter("clojure.lang%.Namespace#refer()","Variable:var")
move_method("isMacro()","clojure.lang%.Var","clojure.lang%.Variable")
rename_method("clojure.asm.commons%.GeneratorAdapter#pop2()","clojure.asm.commons%.GeneratorAdapter#popLongDouble()","clojure.asm.commons%.GeneratorAdapter")
consolidate_duplicate_cond_fragments("clojure.lang%.EdnReader#MetaReader#invoke()")
move_method("shortValue()","clojure.lang%.BigInt","clojure.lang%.ClojureBigInteger")
replace_method_with_method_object("clojure.lang%.ArraySeq#ArraySeq_boolean#next()","clojure.lang%.ClojureObject")
replace_method_with_method_object("clojure.lang%.Compiler#FnExpr#parse()","clojure.lang%.Variable")
move_method("alter()","clojure.lang%.Ref","clojure.lang%.Reference")
move_method("toBigInteger()","clojure.lang%.BigInt","clojure.lang%.ClojureBigInteger")
move_method("getRawRoot()","clojure.lang%.Var","clojure.lang%.Variable")
inline_method("clojure.lang%.LazySeq#lastIndexOf()","clojure.lang%.LazySeq#reify()","newArrayList(this)","clojure.lang%.LazySeq")
rename_method("clojure.lang%.FnLoaderThunk#meta()","clojure.lang%.FnLoaderThunk#getMeta()","clojure.lang%.FnLoaderThunk")
replace_method_with_method_object("clojure.lang%.Compiler#TryExpr#Parser#parse()","clojure.lang%.Variable")
consolidate_duplicate_cond_fragments("clojure.lang%.LockingTransaction#run()")
move_method("call()","clojure.lang%.Ref","clojure.lang%.Reference")
replace_method_with_method_object("clojure.lang%.LispReader#ConditionalReader#readCondDelimited()","clojure.lang%.Variable")
rename_method("clojure.lang%.PersistentTreeMap#meta()","clojure.lang%.PersistentTreeMap#getMeta()","clojure.lang%.PersistentTreeMap")
move_method("histCount()","clojure.lang%.Ref","clojure.lang%.Reference")
add_parameter("clojure.lang%.LockingTransaction#Notify#<init>()","Reference:ref")
move_method("intern()","clojure.lang%.Var","clojure.lang%.Variable")
move_method("fromBigInteger()","clojure.lang%.BigInt","clojure.lang%.ClojureBigInteger")
replace_method_with_method_object("clojure.lang%.LispReader#SyntaxQuoteReader#syntaxQuote()","clojure.lang%.Variable")
rename_method("clojure.lang%.PersistentArrayMap#meta()","clojure.lang%.PersistentArrayMap#getMeta()","clojure.lang%.PersistentArrayMap")
move_method("fn()","clojure.lang%.Var","clojure.lang%.Reference")
extract_interface("clojure.lang.interfaces%.ISeq","clojure.lang%.PersistentList#EmptyList")
replace_method_with_method_object("clojure.lang%.Compiler#CaseExpr#Parser#parse()","clojure.lang%.Variable")
replace_method_with_method_object("clojure.lang%.LockingTransaction#run()","clojure.lang%.Reference#TVal")
move_field("lpart","clojure.lang%.BigInt","clojure.lang%.ClojureBigInteger")
move_field("nsKey","clojure.lang%.Var","clojure.lang%.Variable")
rename_method("clojure.lang%.APersistentSet#equiv()","clojure.lang%.APersistentSet#isEquivalent()","clojure.lang%.APersistentSet")
move_method("floatValue()","clojure.lang%.BigInt","clojure.lang%.ClojureBigInteger")
replace_method_with_method_object("clojure.lang%.RT#print()","clojure.lang%.Variable")
move_method("invoke()","clojure.lang%.Ref","clojure.lang%.Reference")
replace_constructor_with_factory_method("clojure.lang%.ClojureBigInteger#<init>()","clojure.lang%.ClojureBigInteger#fromBigInteger()")
replace_constructor_with_factory_method("clojure.lang%.ClojureBigInteger#<init>()","clojure.lang%.ClojureBigInteger#valueOf()")
replace_method_with_method_object("clojure.lang%.RT#load()","clojure.lang%.Variable")
add_parameter("clojure.lang%.FnLoaderThunk#<init>()","Variable:v")
extract_interface("clojure.lang.interfaces%.IFn","clojure.lang%.Keyword")
move_method("set()","clojure.lang%.Var","clojure.lang%.Variable")
move_method("invoke()","clojure.lang%.Var","clojure.lang%.Variable")
extract_method("clojure.lang%.PersistentTreeMap#without()","clojure.lang%.PersistentTreeMap#getMeta()","_meta","clojure.lang%.PersistentTreeMap")
move_method("get()","clojure.lang%.Var","clojure.lang%.Variable")
move_field("next","clojure.lang%.Ref#TVal","clojure.lang%.Reference#TVal")
consolidate_duplicate_cond_fragments("clojure.lang%.Numbers#toBigInteger()")
move_method("run()","clojure.lang%.Var","clojure.lang%.Reference")
move_method("bitLength()","clojure.lang%.BigInt","clojure.lang%.ClojureBigInteger")
consolidate_duplicate_cond_fragments("clojure.lang%.Numbers#divide()")
move_method("getTag()","clojure.lang%.Var","clojure.lang%.Variable")
move_field("dissoc","clojure.lang%.Var","clojure.lang%.Variable")
extract_method("clojure.lang%.PersistentVector#pop()","clojure.lang%.PersistentVector#getMeta()","_meta","clojure.lang%.PersistentVector")
replace_nested_cond_guard_clauses("clojure.lang%.Numbers#divide()")
move_method("toString()","clojure.lang%.Var#Unbound","clojure.lang%.Variable#Unbound")
replace_constructor_with_factory_method("clojure.lang%.ClojureBigInteger#<init>()","clojure.lang%.ClojureBigInteger#fromLong()")
consolidate_duplicate_cond_fragments("clojure.lang%.Compiler#InvokeExpr#<init>()")
move_field("dvals","clojure.lang%.Var","clojure.lang%.Variable")
rename_method("clojure.lang%.PersistentVector#meta()","clojure.lang%.PersistentVector#getMeta()","clojure.lang%.PersistentVector")
replace_method_with_method_object("clojure.lang%.Compiler#compile1()","clojure.lang%.Variable")
remove_parameter("clojure.lang%.LockingTransaction#releaseIfEnsured()","Ref:ref")
rename_method("clojure.asm%.Attribute#put()","clojure.asm%.Attribute#writeAllAtributes()","clojure.asm%.Attribute")
consolidate_duplicate_cond_fragments("clojure.lang%.Numbers#ops()")
replace_method_with_method_object("clojure.lang%.Compiler#InvokeExpr#emitProto()","clojure.lang%.Variable")
remove_parameter("clojure.lang%.Compiler#StaticInvokeExpr#parse()","Var:v")
add_parameter("clojure.lang%.Compiler#registerVarCallsite()","Variable:v")
move_method("fromLong()","clojure.lang%.BigInt","clojure.lang%.ClojureBigInteger")
move_method("run()","clojure.lang%.Var","clojure.lang%.Variable")
remove_parameter("clojure.lang%.LockingTransaction#doEnsure()","Ref:ref")
consolidate_duplicate_cond_fragments("clojure.lang%.Compiler#maybeResolveIn()")
replace_method_with_method_object("clojure.lang%.Compiler#macroexpand1()","clojure.lang%.Variable")
extract_interface("clojure.lang.interfaces%.ISeq","clojure.lang%.ASeq")
move_method("deref()","clojure.lang%.Var","clojure.lang%.Variable")
move_method("toString()","clojure.lang%.BigInt","clojure.lang%.ClojureBigInteger")
replace_method_with_method_object("clojure.lang%.Compiler#analyzeSeq()","clojure.lang%.Variable")
move_method("currentVal()","clojure.lang%.Ref","clojure.lang%.Reference")
add_parameter("clojure.lang%.Compiler#VarExpr#<init>()","Variable:var")
consolidate_duplicate_cond_fragments("clojure.lang%.Compiler#macroexpand1()")
move_field("tvals","clojure.lang%.Ref","clojure.lang%.Reference")
move_method("applyTo()","clojure.lang%.Ref","clojure.lang%.Reference")
move_method("setMeta()","clojure.lang%.Var","clojure.lang%.Variable")
move_field("ids","clojure.lang%.Ref","clojure.lang%.Reference")
consolidate_duplicate_cond_fragments("clojure.lang%.Compiler#lookupVar()")
move_method("quotient()","clojure.lang%.BigInt","clojure.lang%.ClojureBigInteger")
introduce_local_extension("clojure.asm%.ObjectVisitor","clojure.asm%.AnnotationVisitor")
extract_interface("clojure.lang%.IClojureObject","clojure.lang%.APersistentVector#SubVector")
replace_method_with_method_object("clojure.lang%.Compile#main()","clojure.lang%.Variable")
add_parameter("clojure.lang%.Compiler#registerVar()","Variable:var")
extract_interface("clojure.lang%.IClojureObject","clojure.lang%.PersistentArrayMap")
replace_method_with_method_object("clojure.lang%.ArraySeq#ArraySeq_int#next()","clojure.lang%.ClojureObject")
move_method("run()","clojure.lang%.Ref","clojure.lang%.Variable")
move_method("touch()","clojure.lang%.Ref","clojure.lang%.Reference")
rename_method("clojure.lang%.ExceptionInfo#getData()","clojure.lang%.ExceptionInfo#getExceptionData()","clojure.lang%.ExceptionInfo")
move_method("fn()","clojure.lang%.Var","clojure.lang%.Variable")
rename_method("clojure.lang%.PersistentTreeSet#meta()","clojure.lang%.PersistentTreeSet#getMeta()","clojure.lang%.PersistentTreeSet")
extract_interface("clojure.lang%.IClojureObject","clojure.lang%.AFunction")
replace_method_with_method_object("clojure.lang%.Compiler#DefExpr#Parser#parse()","clojure.lang%.Variable")
replace_method_with_method_object("clojure.lang%.ArraySeq#ArraySeq_byte#next()","clojure.lang%.ClojureObject")
move_method("getThreadBindingFrame()","clojure.lang%.Var","clojure.lang%.Variable")
extract_method("clojure.lang%.Compiler#FnMethod#doEmitStatic()","clojure.lang%.Compiler#FnMethod#generatePrimInvoke()","TypeTypeGeneratorAdaptergenif(prim!=null)if(retClass==double.class||retClass==long.class)Type=getReturnType()elseType=OBJECT_TYPEMethodpm=newMethod(invokePrim,Type,argtypes)gen=newGeneratorAdapter(ACC_PUBLIC+ACC_FINAL,pm,null,EXCEPTION_TYPES,cv)gen.visitCode()for(inti=0i<argtypes.lengthi++)gen.loadArg(i)if(!argclasses[i].isPrimitive())gen.visitInsn(Opcodes.ACONST_NULL)gen.storeArg(i)gen.invokeStatic(objx.objtype,ms)gen.Value()gen.endMethod()","clojure.lang%.Compiler#FnMethod")
rename_method("clojure.lang%.Symbol#meta()","clojure.lang%.Symbol#getMeta()","clojure.lang%.Symbol")
move_method("swapRoot()","clojure.lang%.Var","clojure.lang%.Variable")
remove_parameter("clojure.lang%.Compiler#registerVarCallsite()","Var:v")
rename_method("clojure.lang%.ASeq#equiv()","clojure.lang%.ASeq#isEquivalent()","clojure.lang%.ASeq")
extract_interface("clojure.lang%.IClojureObject","clojure.lang%.PersistentHashMap")
remove_parameter("clojure.lang%.LockingTransaction#Notify#<init>()","Ref:ref")
consolidate_duplicate_cond_fragments("clojure.asm%.Frame#pop()")
move_method("lt()","clojure.lang%.BigInt","clojure.lang%.ClojureBigInteger")
move_method("setValidator()","clojure.lang%.Var","clojure.lang%.Variable")
extract_interface("clojure.lang%.IClojureObject","clojure.lang%.PersistentTreeMap")
move_method("initialValue()","clojure.lang%.Var#1","clojure.lang%.Variable#1")
move_method("getMinHistory()","clojure.lang%.Ref","clojure.lang%.Reference")
move_field("minHistory","clojure.lang%.Ref","clojure.lang%.Reference")
consolidate_duplicate_cond_fragments("clojure.lang%.Compiler#LetExpr#doEmit()")
move_method("valueOf()","clojure.lang%.BigInt","clojure.lang%.ClojureBigInteger")
move_method("applyTo()","clojure.lang%.Var","clojure.lang%.Reference")
move_method("byteValue()","clojure.lang%.BigInt","clojure.lang%.ClojureBigInteger")
move_method("longValue()","clojure.lang%.BigInt","clojure.lang%.ClojureBigInteger")
rename_method("clojure.lang%.PersistentQueue#equiv()","clojure.lang%.PersistentQueue#isEquivalent()","clojure.lang%.PersistentQueue")
move_method("setMaxHistory()","clojure.lang%.Ref","clojure.lang%.Reference")
add_parameter("clojure.lang%.LockingTransaction#doSet()","Reference:ref")
consolidate_duplicate_cond_fragments("clojure.lang%.LispReader#EvalReader#invoke()")
move_method("trimHistory()","clojure.lang%.Ref","clojure.lang%.Reference")
replace_method_with_method_object("clojure.lang%.Compiler#NewInstanceMethod#parse()","clojure.lang%.Variable")
move_method("doSet()","clojure.lang%.Var","clojure.lang%.Variable")
move_method("applyTo()","clojure.lang%.Var","clojure.lang%.Variable")
move_method("getHistoryCount()","clojure.lang%.Ref","clojure.lang%.Reference")
move_field("prior","clojure.lang%.Ref#TVal","clojure.lang%.Reference#TVal")
move_method("commuteRoot()","clojure.lang%.Var","clojure.lang%.Variable")
add_parameter("clojure.lang%.Compiler#InvokeExpr#sigTag()","Variable:v")
remove_parameter("clojure.lang%.Compiler#VarExpr#<init>()","Var:var")
remove_control_flag("found","clojure.lang%.APersistentMap#equiv()")
remove_parameter("clojure.lang%.LockingTransaction#doCommute()","Ref:ref")
move_field("point","clojure.lang%.Ref#TVal","clojure.lang%.Reference#TVal")
move_field("privateKey","clojure.lang%.Var","clojure.lang%.Variable")
move_method("isBound()","clojure.lang%.Ref","clojure.lang%.Reference")
consolidate_duplicate_cond_fragments("clojure.lang%.Compiler#TryExpr#Parser#parse()")
move_method("multiply()","clojure.lang%.BigInt","clojure.lang%.ClojureBigInteger")
remove_parameter("clojure.lang%.Compiler#registerProtocolCallsite()","Var:v")
remove_parameter("clojure.lang%.Compiler#ObjExpr#emitVarValue()","Var:v")
move_method("setMinHistory()","clojure.lang%.Ref","clojure.lang%.Reference")
replace_method_with_method_object("clojure.lang%.Compiler#NewInstanceExpr#build()","clojure.lang%.Variable")
replace_method_with_method_object("clojure.lang%.Compiler#analyzeSymbol()","clojure.lang%.Variable")
rename_method("clojure.lang%.APersistentVector#SubVector#meta()","clojure.lang%.APersistentVector#SubVector#getMeta()","clojure.lang%.APersistentVector#SubVector")
move_method("applyTo()","clojure.lang%.Ref","clojure.lang%.Variable")
replace_method_with_method_object("clojure.lang%.Compiler#resolveIn()","clojure.lang%.Variable")
move_method("throwArity()","clojure.lang%.Var#Unbound","clojure.lang%.Variable#Unbound")
remove_parameter("clojure.lang%.FnLoaderThunk#<init>()","Var:v")
move_method("call()","clojure.lang%.Var","clojure.lang%.Reference")
consolidate_duplicate_cond_fragments("clojure.lang%.Compiler#resolveSymbol()")
replace_method_with_method_object("clojure.lang%.ArraySeq#ArraySeq_char#next()","clojure.lang%.ClojureObject")
extract_interface("clojure.lang.interfaces%.IRef","clojure.lang%.ARef")
move_method("visit()","clojure.asm%.AnnotationVisitor","clojure.asm%.ObjectVisitor")
move_field("ns","clojure.lang%.Var","clojure.lang%.Variable")
move_method("internPrivate()","clojure.lang%.Var","clojure.lang%.Variable")
add_parameter("clojure.lang%.LockingTransaction#doEnsure()","Reference:ref")
consolidate_duplicate_cond_fragments("clojure.lang%.Numbers#category()")
introduce_local_extension("clojure.lang%.ClojureBigInteger","long")
replace_method_with_method_object("clojure.lang%.LockingTransaction#run()","clojure.lang%.Reference")
consolidate_duplicate_cond_fragments("clojure.lang%.LispReader#MetaReader#invoke()")
move_method("doubleValue()","clojure.lang%.BigInt","clojure.lang%.ClojureBigInteger")
replace_method_with_method_object("clojure.lang%.LispReader#FnReader#invoke()","clojure.lang%.Variable")
move_method("getMaxHistory()","clojure.lang%.Ref","clojure.lang%.Reference")
inline_method("clojure.lang%.MultiFn#findAndCacheBestMethod()","clojure.lang%.MultiFn#isA()","RT.booleanCast(isa.invoke(hierarchy.deref(),x,y))","clojure.lang%.MultiFn")
add_parameter("clojure.lang%.LockingTransaction#tryWriteLock()","Reference:ref")
move_method("isDynamic()","clojure.lang%.Var","clojure.lang%.Variable")
move_method("run()","clojure.lang%.Ref","clojure.lang%.Reference")
remove_parameter("clojure.lang%.LockingTransaction#tryWriteLock()","Ref:ref")
consolidate_duplicate_cond_fragments("clojure.lang%.Numbers#toBigDecimal()")
move_field("assoc","clojure.lang%.Var","clojure.lang%.Variable")
rename_method("clojure.lang%.APersistentMap#equiv()","clojure.lang%.APersistentMap#isEquivalent()","clojure.lang%.APersistentMap")
remove_parameter("clojure.lang%.Compiler#registerVar()","Var:var")
move_field("root","clojure.lang%.Var","clojure.lang%.Variable")
replace_method_with_method_object("clojure.lang%.ArraySeq#ArraySeq_short#next()","clojure.lang%.ClojureObject")
move_method("remainder()","clojure.lang%.BigInt","clojure.lang%.ClojureBigInteger")
replace_method_with_method_object("clojure.lang%.Compiler#load()","clojure.lang%.Variable")
move_field("privateMeta","clojure.lang%.Var","clojure.lang%.Variable")
rename_method("clojure.lang%.PersistentList#Primordial#meta()","clojure.lang%.PersistentList#Primordial#getMeta()","clojure.lang%.PersistentList#Primordial")
move_method("unbindRoot()","clojure.lang%.Var","clojure.lang%.Variable")
move_method("clone()","clojure.lang%.Var#Frame","clojure.lang%.Variable#Frame")
move_field("rev","clojure.lang%.Var","clojure.lang%.Variable")
move_field("lock","clojure.lang%.Ref","clojure.lang%.Reference")
replace_method_with_method_object("clojure.lang%.Util#loadWithClass()","clojure.lang%.Variable")
move_method("invoke()","clojure.lang%.Var","clojure.lang%.Reference")
extract_method("clojure.lang%.PersistentTreeMap#assoc()","clojure.lang%.PersistentTreeMap#getMeta()","_meta","clojure.lang%.PersistentTreeMap")
extract_interface("clojure.lang%.IClojureObject","clojure.lang%.PersistentStructMap")
move_field("val","clojure.lang%.Ref#TVal","clojure.lang%.Variable#TBox")
move_field("sym","clojure.lang%.Var","clojure.lang%.Variable")
move_field("nameKey","clojure.lang%.Var","clojure.lang%.Variable")
extract_method("clojure.lang%.PersistentTreeMap#assocEx()","clojure.lang%.PersistentTreeMap#getMeta()","_meta","clojure.lang%.PersistentTreeMap")
move_field("threadBound","clojure.lang%.Var","clojure.lang%.Variable")
introduce_local_extension("clojure.lang%.ClojureBigInteger","java.math%.BigInteger")
replace_method_with_method_object("clojure.lang%.Namespace#intern()","clojure.lang%.Variable")
inline_method("clojure.lang%.LazySeq#listIterator()","clojure.lang%.LazySeq#reify()","newArrayList(this)","clojure.lang%.LazySeq")
move_field("v","clojure.lang%.Var#Unbound","clojure.lang%.Variable#Unbound")
consolidate_duplicate_cond_fragments("clojure.lang%.Compiler#ObjExpr#constantType()")
move_method("intValue()","clojure.lang%.BigInt","clojure.lang%.ClojureBigInteger")
move_field("tinfo","clojure.lang%.Ref","clojure.lang%.Reference")
extract_interface("clojure.lang.interfaces%.ISeq","clojure.lang%.LazySeq")
remove_parameter("clojure.lang%.LockingTransaction#doSet()","Ref:ref")
replace_temp_with_query("clojure.lang%.Compiler#ObjExpr#compile()","clojure.lang%.Compiler#ObjExpr#getStringMap()")
move_method("setTag()","clojure.lang%.Var","clojure.lang%.Variable")
move_method("hasRoot()","clojure.lang%.Var","clojure.lang%.Variable")
move_method("pushThreadBindings()","clojure.lang%.Var","clojure.lang%.Variable")
move_method("compareTo()","clojure.lang%.Ref","clojure.lang%.Reference")
move_method("invoke()","clojure.lang%.Var#2","clojure.lang%.Variable#2")
move_method("alterRoot()","clojure.lang%.Var","clojure.lang%.Variable")
move_method("alter()","clojure.lang%.Var","clojure.lang%.Variable")
remove_assignment_to_parameters("clojure.lang%.Compiler#NewInstanceExpr#build()","IPersistentMap:opts")
introduce_local_extension("clojure.asm%.ObjectVisitor","java.lang%.Object")
introduce_local_extension("clojure.lang%.ClojureBigInteger","clojure.lang%.IHashEq")
inline_method("clojure.lang%.LazySeq#subList()","clojure.lang%.LazySeq#reify()","newArrayList(this)","clojure.lang%.LazySeq")
move_method("equals()","clojure.lang%.BigInt","clojure.lang%.ClojureBigInteger")
move_field("val","clojure.lang%.Var#TBox","clojure.lang%.Reference#TVal")
replace_method_with_method_object("clojure.lang%.EdnReader#matchNumber()","clojure.lang%.ClojureBigInteger")
add_parameter("clojure.lang%.Compiler#ObjExpr#emitVar()","Variable:var")
extract_interface("clojure.lang%.IClojureObject","clojure.lang%.Symbol")
move_field("faults","clojure.lang%.Ref","clojure.lang%.Reference")
move_method("toBigDecimal()","clojure.lang%.BigInt","clojure.lang%.ClojureBigInteger")
replace_method_with_method_object("clojure.lang%.Compiler#FnMethod#parse()","clojure.lang%.Variable")
consolidate_duplicate_cond_fragments("clojure.lang%.RT#longCast()")
consolidate_duplicate_cond_fragments("clojure.lang%.Numbers#rationalize()")
move_method("setDynamic()","clojure.lang%.Var","clojure.lang%.Variable")
move_method("call()","clojure.lang%.Ref","clojure.lang%.Variable")
inline_method("clojure.lang%.ASeq#listIterator()","clojure.lang%.ASeq#reify()","Collections.unmodifiableList(newArrayList(this))","clojure.lang%.ASeq")
replace_method_with_method_object("clojure.lang%.RT#print()","clojure.lang%.ClojureObject")
inline_method("clojure.lang%.Util#hasheq()","clojure.lang%.Util#dohasheq()","o.hasheq()","clojure.lang%.Util")
move_method("doReset()","clojure.lang%.Var","clojure.lang%.Variable")
introduce_local_extension("clojure.lang%.ClojureBigInteger","clojure.lang%.ClojureBigInteger")
move_method("reduceBigInt()","clojure.lang%.Numbers","clojure.lang%.ClojureBigInteger")
move_method("commute()","clojure.lang%.Ref","clojure.lang%.Reference")
remove_parameter("clojure.lang%.Namespace#refer()","Var:var")
remove_parameter("clojure.lang%.Compiler#DefExpr#<init>()","Var:var")
rename_method("clojure.lang%.LazySeq#equiv()","clojure.lang%.LazySeq#isEquivalent()","clojure.lang%.LazySeq")
add_parameter("clojure.lang%.Compiler#registerProtocolCallsite()","Variable:v")
extract_method("clojure.lang%.Compiler#NewInstanceExpr#build()","clojure.lang%.Compiler#NewInstanceExpr#getInstanceExpr()","NewInstanceExprret=newNewInstanceExpr(null)ret.src=frmret.name=className.toString()ret.classMeta=RT.meta(className)ret.internalName=ret.name.replace('.','/')ret.objtype=Type.getObjectType(ret.internalName)ret.opts=optsif(thisSym!=null)ret.thisName=thisSym.nameif(fieldSyms!=null)IPersistentMapfmap=PersistentHashMap.EMPTYObject[]closesvec=newObject[2*fieldSyms.count()]for(inti=0i<fieldSyms.count()i++)Symbolsym=(Symbol)fieldSyms.nth(i)LocalBindinglb=newLocalBinding(-1,sym,null,newMethodParamExpr(tagClass(tagOf(sym))),false,null)fmap=fmap.assoc(sym,lb)closesvec[i*2]=lbclosesvec[i*2+1]=lbret.closes=newPersistentArrayMap(closesvec)ret.fields=fmapfor(inti=fieldSyms.count()-1i>=0&&(((Symbol)fieldSyms.nth(i)).name.equals(__meta)||((Symbol)fieldSyms.nth(i)).name.equals(__extmap))--i)ret.altCtorDrops++ret","clojure.lang%.Compiler#NewInstanceExpr")
remove_parameter("clojure.lang%.Compiler#ObjExpr#emitVar()","Var:var")
introduce_local_extension("clojure.lang%.ClojureBigInteger","java.lang%.Number")
replace_method_with_method_object("clojure.lang%.Compiler#LetExpr#Parser#parse()","clojure.lang%.Variable")
move_field("val","clojure.lang%.Var#TBox","clojure.lang%.Variable#TBox")
inline_method("clojure.lang%.PersistentTreeMap#assoc()","clojure.lang%.PersistentTreeMap#meta()","_meta","clojure.lang%.PersistentTreeMap")
rename_method("clojure.lang%.PersistentHashSet#meta()","clojure.lang%.PersistentHashSet#getMeta()","clojure.lang%.PersistentHashSet")
remove_parameter("clojure.lang%.LockingTransaction#doGet()","Ref:ref")
replace_method_with_method_object("clojure.lang%.MultiFn#findAndCacheBestMethod()","clojure.lang%.Variable")
add_parameter("clojure.lang%.Compiler#DefExpr#<init>()","Variable:var")
move_field("maxHistory","clojure.lang%.Ref","clojure.lang%.Reference")
move_field("id","clojure.lang%.Ref","clojure.lang%.Reference")
move_field("_meta","clojure.lang%.Obj","clojure.lang%.ClojureObject")
add_parameter("clojure.lang%.Compiler#TheVarExpr#<init>()","Variable:var")
move_method("deref()","clojure.lang%.Ref","clojure.lang%.Reference")
replace_method_with_method_object("clojure.lang%.RT#doInit()","clojure.lang%.Variable")
move_method("isBound()","clojure.lang%.Var","clojure.lang%.Variable")
replace_method_with_method_object("clojure.lang%.Compiler#LetFnExpr#Parser#parse()","clojure.lang%.Variable")
replace_method_with_method_object("clojure.lang%.Compiler#InvokeExpr#parse()","clojure.lang%.Variable")
rename_method("clojure.lang%.PersistentStructMap#meta()","clojure.lang%.PersistentStructMap#getMeta()","clojure.lang%.PersistentStructMap")
rename_method("clojure.lang%.PersistentHashMap#meta()","clojure.lang%.PersistentHashMap#getMeta()","clojure.lang%.PersistentHashMap")
move_field("TOP","clojure.lang%.Var#Frame","clojure.lang%.Variable#Frame")
add_parameter("clojure.lang%.Compiler#StaticInvokeExpr#parse()","Variable:v")
rename_method("clojure.lang%.AFunction#meta()","clojure.lang%.AFunction#getMeta()","clojure.lang%.AFunction")
move_method("popThreadBindings()","clojure.lang%.Var","clojure.lang%.Variable")
consolidate_duplicate_cond_fragments("clojure.lang%.Compiler#resolveIn()")
replace_method_with_method_object("clojure.lang%.Compiler#compile()","clojure.lang%.Variable")
add_parameter("clojure.lang%.LockingTransaction#lock()","Reference:ref")
move_method("bindRoot()","clojure.lang%.Var","clojure.lang%.Variable")
move_method("fn()","clojure.lang%.Ref","clojure.lang%.Variable")
add_parameter("clojure.lang%.Compiler#ObjExpr#emitVarValue()","Variable:v")
